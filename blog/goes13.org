# Created 2017-01-31 Tue 23:51
#+OPTIONS: ':nil *:t -:t ::t <:t H:3 \n:nil ^:t arch:headline author:t c:nil
#+OPTIONS: creator:nil d:(not "LOGBOOK") date:t e:t email:nil f:t inline:t
#+OPTIONS: num:t p:nil pri:nil prop:nil stat:t tags:t tasks:t tex:t timestamp:t
#+OPTIONS: title:t toc:t todo:t |:t
#+TITLE: Exploring GOES 13 Satellite Data with Python and Emacs
#+DATE: <2017-01-31 Tue>
#+AUTHOR: Julien Chastang
#+LANGUAGE: en
#+SELECT_TAGS: export
#+EXCLUDE_TAGS: noexport
#+SETUPFILE: ../../templates/level-1.org
#+PROPERTY: header-args :tangle goes13.py

* <2017-01-30 Mon>

I recently came across some [[https://en.wikipedia.org/wiki/GOES_13][GOES 13]] satellite data ([[http://jetstream.unidata.ucar.edu/repository/entry/show?entryid=5c36288d-208d-46f4-a8c7-228127a6e0f2][available here]]) I wanted to visualize. In order to do that, we can make use of the [[file:emacs-docker.org][Emacs Docker container I wrote about previously]] that has a full-fledged Scientific Python environment. The data in question are in [[http://www.unidata.ucar.edu/software/netcdf/][netCDF format]]. Everything that follows could be done with a [[http://jupyter.org/][Jupyter notebook]], but it's often best to keep our workflows within Emacs and org-mode whenever possible.

In order to crack open and visualize the data, we will need our usual suite of Scientific Python APIs.

#+BEGIN_SRC ipython
  import numpy as np
  import numpy.ma as ma
  import matplotlib.pyplot as plt
  import netCDF4
  from cartopy import config
  import cartopy.crs as ccrs

  # for inlining plots
  %matplotlib inline
#+END_SRC

Now, open the data via OpenDAP with the netcdf4-python API and print the header:

#+BEGIN_SRC ipython
  opendapurl = "http://jetstream.unidata.ucar.edu/repository/opendap/5c36288d-208d-46f4-a8c7-228127a6e0f2/entry.das" 
  nc = netCDF4.Dataset(opendapurl)
  # if opening as a local file
  # nc = netCDF4.Dataset("goes13.2017.001.114518.BAND_04.nc")
  nc
#+END_SRC

The header information reveals we are dealing with a [[https://www.ssec.wisc.edu/mcidas/doc/prog_man/2015/formats-1.html][McIDAS Area File]] that has been converted to netCDF. It has no coordinate variables. The ~Satellite Sensor~ global attribute hints that we have [[https://en.wikipedia.org/wiki/GOES_13][GOES-13]] satellite data. Many of the variables (e.g., ~elemRes~) refer to Area file metadata. The most interesting variables are probably ~lat~, ~lon~ and ~data~. Let's look at the ~lat~ variable in more detail:

#+BEGIN_SRC ipython
  ncvars = nc.variables
  lat = ncvars['lat']
  # print the variable attributes
  lat
#+END_SRC

~lat~ variable contains:

#+BEGIN_SRC ipython
  lat[:]
#+END_SRC

Even though the variable metadata indicates no fill value, we've probably stumbled upon one with the ~2.14328934e+09~ repeated values. Let's create a numpy mask that will mask out that part of the two-dimensional array:

#+BEGIN_SRC ipython
  datamask = ma.masked_values(lat[:], 2.14328934e+09)
#+END_SRC

Before we make use of our mask, let's get the ~lon~ and ~data~:

#+BEGIN_SRC ipython
  lon = ncvars['lon']
  data = ncvars['data']
  data
#+END_SRC

The ~data~ variable contains satellite brightness temperature in a range of values between ~0~ and ~255~. Note the shape of the ~data~ variable is the same as the ~lat~ and ~lon~ but with an additional time dimension of length one. Let's now employ our ~datamask~ described earlier. For the ~data~ variable, we will retrieve the first and only time step (~data[0]~) before masking.

#+BEGIN_SRC ipython
  datam = ma.masked_array(data[0], datamask.mask)
  latm = ma.masked_array(lat, datamask.mask)
  lonm = ma.masked_array(lon, datamask.mask)
#+END_SRC

At this point, all we have to do is plot up the data with the help of the [[http://scitools.org.uk/cartopy/index.html][Cartopy API]].

#+BEGIN_SRC ipython
  plt.figure(figsize=(6, 6))
  ax = plt.axes(projection=ccrs.PlateCarree())
  plt.contourf(lonm, latm, datam, 60, cmap='bone', transform=ccrs.PlateCarree())
  ax.coastlines()
  plt.show()
#+END_SRC
